// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.30.2
// source: network.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "chess";

export enum MoveType {
  MOVE_TYPE_NORMAL = 0,
  MOVE_TYPE_CASTLE = 1,
  MOVE_TYPE_EN_PASSANT = 2,
  UNRECOGNIZED = -1,
}

export function moveTypeFromJSON(object: any): MoveType {
  switch (object) {
    case 0:
    case "MOVE_TYPE_NORMAL":
      return MoveType.MOVE_TYPE_NORMAL;
    case 1:
    case "MOVE_TYPE_CASTLE":
      return MoveType.MOVE_TYPE_CASTLE;
    case 2:
    case "MOVE_TYPE_EN_PASSANT":
      return MoveType.MOVE_TYPE_EN_PASSANT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MoveType.UNRECOGNIZED;
  }
}

export function moveTypeToJSON(object: MoveType): string {
  switch (object) {
    case MoveType.MOVE_TYPE_NORMAL:
      return "MOVE_TYPE_NORMAL";
    case MoveType.MOVE_TYPE_CASTLE:
      return "MOVE_TYPE_CASTLE";
    case MoveType.MOVE_TYPE_EN_PASSANT:
      return "MOVE_TYPE_EN_PASSANT";
    case MoveType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PieceType {
  PIECE_TYPE_PAWN = 0,
  PIECE_TYPE_KNIGHT = 1,
  PIECE_TYPE_BISHOP = 2,
  PIECE_TYPE_ROOK = 3,
  PIECE_TYPE_QUEEN = 4,
  PIECE_TYPE_KING = 5,
  PIECE_TYPE_PROMOTED_PAWN = 6,
  UNRECOGNIZED = -1,
}

export function pieceTypeFromJSON(object: any): PieceType {
  switch (object) {
    case 0:
    case "PIECE_TYPE_PAWN":
      return PieceType.PIECE_TYPE_PAWN;
    case 1:
    case "PIECE_TYPE_KNIGHT":
      return PieceType.PIECE_TYPE_KNIGHT;
    case 2:
    case "PIECE_TYPE_BISHOP":
      return PieceType.PIECE_TYPE_BISHOP;
    case 3:
    case "PIECE_TYPE_ROOK":
      return PieceType.PIECE_TYPE_ROOK;
    case 4:
    case "PIECE_TYPE_QUEEN":
      return PieceType.PIECE_TYPE_QUEEN;
    case 5:
    case "PIECE_TYPE_KING":
      return PieceType.PIECE_TYPE_KING;
    case 6:
    case "PIECE_TYPE_PROMOTED_PAWN":
      return PieceType.PIECE_TYPE_PROMOTED_PAWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PieceType.UNRECOGNIZED;
  }
}

export function pieceTypeToJSON(object: PieceType): string {
  switch (object) {
    case PieceType.PIECE_TYPE_PAWN:
      return "PIECE_TYPE_PAWN";
    case PieceType.PIECE_TYPE_KNIGHT:
      return "PIECE_TYPE_KNIGHT";
    case PieceType.PIECE_TYPE_BISHOP:
      return "PIECE_TYPE_BISHOP";
    case PieceType.PIECE_TYPE_ROOK:
      return "PIECE_TYPE_ROOK";
    case PieceType.PIECE_TYPE_QUEEN:
      return "PIECE_TYPE_QUEEN";
    case PieceType.PIECE_TYPE_KING:
      return "PIECE_TYPE_KING";
    case PieceType.PIECE_TYPE_PROMOTED_PAWN:
      return "PIECE_TYPE_PROMOTED_PAWN";
    case PieceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ClientPing {
}

export interface ClientSubscribe {
  centerX: number;
  centerY: number;
}

export interface ClientMove {
  pieceId: number;
  fromX: number;
  fromY: number;
  toX: number;
  toY: number;
  moveType: MoveType;
  moveToken: number;
}

export interface ClientMessage {
  payload?: { $case: "ping"; value: ClientPing } | { $case: "subscribe"; value: ClientSubscribe } | {
    $case: "move";
    value: ClientMove;
  } | undefined;
}

export interface ServerValidMove {
  asOfSeqnum: number;
  moveToken: number;
  capturedPieceId: number;
}

export interface ServerInvalidMove {
  moveToken: number;
}

export interface ServerPong {
}

export interface PieceCapture {
  capturedPieceId: number;
  seqnum: number;
}

export interface PieceDataShared {
  id: number;
  type: PieceType;
  isWhite: boolean;
  justDoubleMoved: boolean;
  kingKiller: boolean;
  kingPawner: boolean;
  queenKiller: boolean;
  queenPawner: boolean;
  adoptedKiller: boolean;
  adopted: boolean;
  hasCapturedPieceTypeOtherThanOwn: boolean;
  moveCount: number;
  captureCount: number;
}

export interface PieceDataForMove {
  x: number;
  y: number;
  seqnum: number;
  piece: PieceDataShared | undefined;
}

export interface PieceDataForSnapshot {
  dx: number;
  dy: number;
  piece: PieceDataShared | undefined;
}

export interface ServerMovesAndCaptures {
  moves: PieceDataForMove[];
  captures: PieceCapture[];
}

export interface ServerStateSnapshot {
  xCoord: number;
  yCoord: number;
  seqnum: number;
  pieces: PieceDataForSnapshot[];
}

export interface Position {
  x: number;
  y: number;
}

export interface ServerInitialState {
  playingWhite: boolean;
  position: Position | undefined;
  snapshot: ServerStateSnapshot | undefined;
}

export interface ServerAdoption {
  adoptedIds: number[];
}

export interface ServerBulkCapture {
  seqnum: number;
  capturedIds: number[];
}

export interface ServerMessage {
  payload?:
    | { $case: "initialState"; value: ServerInitialState }
    | { $case: "snapshot"; value: ServerStateSnapshot }
    | { $case: "movesAndCaptures"; value: ServerMovesAndCaptures }
    | { $case: "validMove"; value: ServerValidMove }
    | { $case: "invalidMove"; value: ServerInvalidMove }
    | { $case: "pong"; value: ServerPong }
    | { $case: "adoption"; value: ServerAdoption }
    | { $case: "bulkCapture"; value: ServerBulkCapture }
    | undefined;
}

function createBaseClientPing(): ClientPing {
  return {};
}

export const ClientPing: MessageFns<ClientPing> = {
  encode(_: ClientPing, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientPing {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientPing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ClientPing {
    return {};
  },

  toJSON(_: ClientPing): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientPing>, I>>(base?: I): ClientPing {
    return ClientPing.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientPing>, I>>(_: I): ClientPing {
    const message = createBaseClientPing();
    return message;
  },
};

function createBaseClientSubscribe(): ClientSubscribe {
  return { centerX: 0, centerY: 0 };
}

export const ClientSubscribe: MessageFns<ClientSubscribe> = {
  encode(message: ClientSubscribe, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.centerX !== 0) {
      writer.uint32(8).uint32(message.centerX);
    }
    if (message.centerY !== 0) {
      writer.uint32(16).uint32(message.centerY);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientSubscribe {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientSubscribe();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.centerX = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.centerY = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientSubscribe {
    return {
      centerX: isSet(object.centerX) ? globalThis.Number(object.centerX) : 0,
      centerY: isSet(object.centerY) ? globalThis.Number(object.centerY) : 0,
    };
  },

  toJSON(message: ClientSubscribe): unknown {
    const obj: any = {};
    if (message.centerX !== 0) {
      obj.centerX = Math.round(message.centerX);
    }
    if (message.centerY !== 0) {
      obj.centerY = Math.round(message.centerY);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientSubscribe>, I>>(base?: I): ClientSubscribe {
    return ClientSubscribe.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientSubscribe>, I>>(object: I): ClientSubscribe {
    const message = createBaseClientSubscribe();
    message.centerX = object.centerX ?? 0;
    message.centerY = object.centerY ?? 0;
    return message;
  },
};

function createBaseClientMove(): ClientMove {
  return { pieceId: 0, fromX: 0, fromY: 0, toX: 0, toY: 0, moveType: 0, moveToken: 0 };
}

export const ClientMove: MessageFns<ClientMove> = {
  encode(message: ClientMove, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pieceId !== 0) {
      writer.uint32(8).uint32(message.pieceId);
    }
    if (message.fromX !== 0) {
      writer.uint32(16).uint32(message.fromX);
    }
    if (message.fromY !== 0) {
      writer.uint32(24).uint32(message.fromY);
    }
    if (message.toX !== 0) {
      writer.uint32(32).uint32(message.toX);
    }
    if (message.toY !== 0) {
      writer.uint32(40).uint32(message.toY);
    }
    if (message.moveType !== 0) {
      writer.uint32(48).int32(message.moveType);
    }
    if (message.moveToken !== 0) {
      writer.uint32(56).uint32(message.moveToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientMove {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientMove();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pieceId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fromX = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fromY = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.toX = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.toY = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.moveType = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.moveToken = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientMove {
    return {
      pieceId: isSet(object.pieceId) ? globalThis.Number(object.pieceId) : 0,
      fromX: isSet(object.fromX) ? globalThis.Number(object.fromX) : 0,
      fromY: isSet(object.fromY) ? globalThis.Number(object.fromY) : 0,
      toX: isSet(object.toX) ? globalThis.Number(object.toX) : 0,
      toY: isSet(object.toY) ? globalThis.Number(object.toY) : 0,
      moveType: isSet(object.moveType) ? moveTypeFromJSON(object.moveType) : 0,
      moveToken: isSet(object.moveToken) ? globalThis.Number(object.moveToken) : 0,
    };
  },

  toJSON(message: ClientMove): unknown {
    const obj: any = {};
    if (message.pieceId !== 0) {
      obj.pieceId = Math.round(message.pieceId);
    }
    if (message.fromX !== 0) {
      obj.fromX = Math.round(message.fromX);
    }
    if (message.fromY !== 0) {
      obj.fromY = Math.round(message.fromY);
    }
    if (message.toX !== 0) {
      obj.toX = Math.round(message.toX);
    }
    if (message.toY !== 0) {
      obj.toY = Math.round(message.toY);
    }
    if (message.moveType !== 0) {
      obj.moveType = moveTypeToJSON(message.moveType);
    }
    if (message.moveToken !== 0) {
      obj.moveToken = Math.round(message.moveToken);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientMove>, I>>(base?: I): ClientMove {
    return ClientMove.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientMove>, I>>(object: I): ClientMove {
    const message = createBaseClientMove();
    message.pieceId = object.pieceId ?? 0;
    message.fromX = object.fromX ?? 0;
    message.fromY = object.fromY ?? 0;
    message.toX = object.toX ?? 0;
    message.toY = object.toY ?? 0;
    message.moveType = object.moveType ?? 0;
    message.moveToken = object.moveToken ?? 0;
    return message;
  },
};

function createBaseClientMessage(): ClientMessage {
  return { payload: undefined };
}

export const ClientMessage: MessageFns<ClientMessage> = {
  encode(message: ClientMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.payload?.$case) {
      case "ping":
        ClientPing.encode(message.payload.value, writer.uint32(10).fork()).join();
        break;
      case "subscribe":
        ClientSubscribe.encode(message.payload.value, writer.uint32(18).fork()).join();
        break;
      case "move":
        ClientMove.encode(message.payload.value, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = { $case: "ping", value: ClientPing.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = { $case: "subscribe", value: ClientSubscribe.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.payload = { $case: "move", value: ClientMove.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientMessage {
    return {
      payload: isSet(object.ping)
        ? { $case: "ping", value: ClientPing.fromJSON(object.ping) }
        : isSet(object.subscribe)
        ? { $case: "subscribe", value: ClientSubscribe.fromJSON(object.subscribe) }
        : isSet(object.move)
        ? { $case: "move", value: ClientMove.fromJSON(object.move) }
        : undefined,
    };
  },

  toJSON(message: ClientMessage): unknown {
    const obj: any = {};
    if (message.payload?.$case === "ping") {
      obj.ping = ClientPing.toJSON(message.payload.value);
    } else if (message.payload?.$case === "subscribe") {
      obj.subscribe = ClientSubscribe.toJSON(message.payload.value);
    } else if (message.payload?.$case === "move") {
      obj.move = ClientMove.toJSON(message.payload.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientMessage>, I>>(base?: I): ClientMessage {
    return ClientMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientMessage>, I>>(object: I): ClientMessage {
    const message = createBaseClientMessage();
    switch (object.payload?.$case) {
      case "ping": {
        if (object.payload?.value !== undefined && object.payload?.value !== null) {
          message.payload = { $case: "ping", value: ClientPing.fromPartial(object.payload.value) };
        }
        break;
      }
      case "subscribe": {
        if (object.payload?.value !== undefined && object.payload?.value !== null) {
          message.payload = { $case: "subscribe", value: ClientSubscribe.fromPartial(object.payload.value) };
        }
        break;
      }
      case "move": {
        if (object.payload?.value !== undefined && object.payload?.value !== null) {
          message.payload = { $case: "move", value: ClientMove.fromPartial(object.payload.value) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseServerValidMove(): ServerValidMove {
  return { asOfSeqnum: 0, moveToken: 0, capturedPieceId: 0 };
}

export const ServerValidMove: MessageFns<ServerValidMove> = {
  encode(message: ServerValidMove, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.asOfSeqnum !== 0) {
      writer.uint32(8).uint64(message.asOfSeqnum);
    }
    if (message.moveToken !== 0) {
      writer.uint32(16).uint32(message.moveToken);
    }
    if (message.capturedPieceId !== 0) {
      writer.uint32(24).uint32(message.capturedPieceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerValidMove {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerValidMove();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.asOfSeqnum = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.moveToken = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.capturedPieceId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerValidMove {
    return {
      asOfSeqnum: isSet(object.asOfSeqnum) ? globalThis.Number(object.asOfSeqnum) : 0,
      moveToken: isSet(object.moveToken) ? globalThis.Number(object.moveToken) : 0,
      capturedPieceId: isSet(object.capturedPieceId) ? globalThis.Number(object.capturedPieceId) : 0,
    };
  },

  toJSON(message: ServerValidMove): unknown {
    const obj: any = {};
    if (message.asOfSeqnum !== 0) {
      obj.asOfSeqnum = Math.round(message.asOfSeqnum);
    }
    if (message.moveToken !== 0) {
      obj.moveToken = Math.round(message.moveToken);
    }
    if (message.capturedPieceId !== 0) {
      obj.capturedPieceId = Math.round(message.capturedPieceId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerValidMove>, I>>(base?: I): ServerValidMove {
    return ServerValidMove.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerValidMove>, I>>(object: I): ServerValidMove {
    const message = createBaseServerValidMove();
    message.asOfSeqnum = object.asOfSeqnum ?? 0;
    message.moveToken = object.moveToken ?? 0;
    message.capturedPieceId = object.capturedPieceId ?? 0;
    return message;
  },
};

function createBaseServerInvalidMove(): ServerInvalidMove {
  return { moveToken: 0 };
}

export const ServerInvalidMove: MessageFns<ServerInvalidMove> = {
  encode(message: ServerInvalidMove, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.moveToken !== 0) {
      writer.uint32(8).uint32(message.moveToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerInvalidMove {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerInvalidMove();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.moveToken = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerInvalidMove {
    return { moveToken: isSet(object.moveToken) ? globalThis.Number(object.moveToken) : 0 };
  },

  toJSON(message: ServerInvalidMove): unknown {
    const obj: any = {};
    if (message.moveToken !== 0) {
      obj.moveToken = Math.round(message.moveToken);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerInvalidMove>, I>>(base?: I): ServerInvalidMove {
    return ServerInvalidMove.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerInvalidMove>, I>>(object: I): ServerInvalidMove {
    const message = createBaseServerInvalidMove();
    message.moveToken = object.moveToken ?? 0;
    return message;
  },
};

function createBaseServerPong(): ServerPong {
  return {};
}

export const ServerPong: MessageFns<ServerPong> = {
  encode(_: ServerPong, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerPong {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerPong();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ServerPong {
    return {};
  },

  toJSON(_: ServerPong): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerPong>, I>>(base?: I): ServerPong {
    return ServerPong.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerPong>, I>>(_: I): ServerPong {
    const message = createBaseServerPong();
    return message;
  },
};

function createBasePieceCapture(): PieceCapture {
  return { capturedPieceId: 0, seqnum: 0 };
}

export const PieceCapture: MessageFns<PieceCapture> = {
  encode(message: PieceCapture, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.capturedPieceId !== 0) {
      writer.uint32(8).uint32(message.capturedPieceId);
    }
    if (message.seqnum !== 0) {
      writer.uint32(16).uint64(message.seqnum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PieceCapture {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePieceCapture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.capturedPieceId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.seqnum = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PieceCapture {
    return {
      capturedPieceId: isSet(object.capturedPieceId) ? globalThis.Number(object.capturedPieceId) : 0,
      seqnum: isSet(object.seqnum) ? globalThis.Number(object.seqnum) : 0,
    };
  },

  toJSON(message: PieceCapture): unknown {
    const obj: any = {};
    if (message.capturedPieceId !== 0) {
      obj.capturedPieceId = Math.round(message.capturedPieceId);
    }
    if (message.seqnum !== 0) {
      obj.seqnum = Math.round(message.seqnum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PieceCapture>, I>>(base?: I): PieceCapture {
    return PieceCapture.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PieceCapture>, I>>(object: I): PieceCapture {
    const message = createBasePieceCapture();
    message.capturedPieceId = object.capturedPieceId ?? 0;
    message.seqnum = object.seqnum ?? 0;
    return message;
  },
};

function createBasePieceDataShared(): PieceDataShared {
  return {
    id: 0,
    type: 0,
    isWhite: false,
    justDoubleMoved: false,
    kingKiller: false,
    kingPawner: false,
    queenKiller: false,
    queenPawner: false,
    adoptedKiller: false,
    adopted: false,
    hasCapturedPieceTypeOtherThanOwn: false,
    moveCount: 0,
    captureCount: 0,
  };
}

export const PieceDataShared: MessageFns<PieceDataShared> = {
  encode(message: PieceDataShared, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.isWhite !== false) {
      writer.uint32(24).bool(message.isWhite);
    }
    if (message.justDoubleMoved !== false) {
      writer.uint32(32).bool(message.justDoubleMoved);
    }
    if (message.kingKiller !== false) {
      writer.uint32(40).bool(message.kingKiller);
    }
    if (message.kingPawner !== false) {
      writer.uint32(48).bool(message.kingPawner);
    }
    if (message.queenKiller !== false) {
      writer.uint32(56).bool(message.queenKiller);
    }
    if (message.queenPawner !== false) {
      writer.uint32(64).bool(message.queenPawner);
    }
    if (message.adoptedKiller !== false) {
      writer.uint32(72).bool(message.adoptedKiller);
    }
    if (message.adopted !== false) {
      writer.uint32(80).bool(message.adopted);
    }
    if (message.hasCapturedPieceTypeOtherThanOwn !== false) {
      writer.uint32(88).bool(message.hasCapturedPieceTypeOtherThanOwn);
    }
    if (message.moveCount !== 0) {
      writer.uint32(96).uint32(message.moveCount);
    }
    if (message.captureCount !== 0) {
      writer.uint32(104).uint32(message.captureCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PieceDataShared {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePieceDataShared();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isWhite = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.justDoubleMoved = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.kingKiller = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.kingPawner = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.queenKiller = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.queenPawner = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.adoptedKiller = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.adopted = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.hasCapturedPieceTypeOtherThanOwn = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.moveCount = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.captureCount = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PieceDataShared {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      type: isSet(object.type) ? pieceTypeFromJSON(object.type) : 0,
      isWhite: isSet(object.isWhite) ? globalThis.Boolean(object.isWhite) : false,
      justDoubleMoved: isSet(object.justDoubleMoved) ? globalThis.Boolean(object.justDoubleMoved) : false,
      kingKiller: isSet(object.kingKiller) ? globalThis.Boolean(object.kingKiller) : false,
      kingPawner: isSet(object.kingPawner) ? globalThis.Boolean(object.kingPawner) : false,
      queenKiller: isSet(object.queenKiller) ? globalThis.Boolean(object.queenKiller) : false,
      queenPawner: isSet(object.queenPawner) ? globalThis.Boolean(object.queenPawner) : false,
      adoptedKiller: isSet(object.adoptedKiller) ? globalThis.Boolean(object.adoptedKiller) : false,
      adopted: isSet(object.adopted) ? globalThis.Boolean(object.adopted) : false,
      hasCapturedPieceTypeOtherThanOwn: isSet(object.hasCapturedPieceTypeOtherThanOwn)
        ? globalThis.Boolean(object.hasCapturedPieceTypeOtherThanOwn)
        : false,
      moveCount: isSet(object.moveCount) ? globalThis.Number(object.moveCount) : 0,
      captureCount: isSet(object.captureCount) ? globalThis.Number(object.captureCount) : 0,
    };
  },

  toJSON(message: PieceDataShared): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.type !== 0) {
      obj.type = pieceTypeToJSON(message.type);
    }
    if (message.isWhite !== false) {
      obj.isWhite = message.isWhite;
    }
    if (message.justDoubleMoved !== false) {
      obj.justDoubleMoved = message.justDoubleMoved;
    }
    if (message.kingKiller !== false) {
      obj.kingKiller = message.kingKiller;
    }
    if (message.kingPawner !== false) {
      obj.kingPawner = message.kingPawner;
    }
    if (message.queenKiller !== false) {
      obj.queenKiller = message.queenKiller;
    }
    if (message.queenPawner !== false) {
      obj.queenPawner = message.queenPawner;
    }
    if (message.adoptedKiller !== false) {
      obj.adoptedKiller = message.adoptedKiller;
    }
    if (message.adopted !== false) {
      obj.adopted = message.adopted;
    }
    if (message.hasCapturedPieceTypeOtherThanOwn !== false) {
      obj.hasCapturedPieceTypeOtherThanOwn = message.hasCapturedPieceTypeOtherThanOwn;
    }
    if (message.moveCount !== 0) {
      obj.moveCount = Math.round(message.moveCount);
    }
    if (message.captureCount !== 0) {
      obj.captureCount = Math.round(message.captureCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PieceDataShared>, I>>(base?: I): PieceDataShared {
    return PieceDataShared.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PieceDataShared>, I>>(object: I): PieceDataShared {
    const message = createBasePieceDataShared();
    message.id = object.id ?? 0;
    message.type = object.type ?? 0;
    message.isWhite = object.isWhite ?? false;
    message.justDoubleMoved = object.justDoubleMoved ?? false;
    message.kingKiller = object.kingKiller ?? false;
    message.kingPawner = object.kingPawner ?? false;
    message.queenKiller = object.queenKiller ?? false;
    message.queenPawner = object.queenPawner ?? false;
    message.adoptedKiller = object.adoptedKiller ?? false;
    message.adopted = object.adopted ?? false;
    message.hasCapturedPieceTypeOtherThanOwn = object.hasCapturedPieceTypeOtherThanOwn ?? false;
    message.moveCount = object.moveCount ?? 0;
    message.captureCount = object.captureCount ?? 0;
    return message;
  },
};

function createBasePieceDataForMove(): PieceDataForMove {
  return { x: 0, y: 0, seqnum: 0, piece: undefined };
}

export const PieceDataForMove: MessageFns<PieceDataForMove> = {
  encode(message: PieceDataForMove, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(8).uint32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(16).uint32(message.y);
    }
    if (message.seqnum !== 0) {
      writer.uint32(24).uint64(message.seqnum);
    }
    if (message.piece !== undefined) {
      PieceDataShared.encode(message.piece, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PieceDataForMove {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePieceDataForMove();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.x = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.y = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.seqnum = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.piece = PieceDataShared.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PieceDataForMove {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      seqnum: isSet(object.seqnum) ? globalThis.Number(object.seqnum) : 0,
      piece: isSet(object.piece) ? PieceDataShared.fromJSON(object.piece) : undefined,
    };
  },

  toJSON(message: PieceDataForMove): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = Math.round(message.x);
    }
    if (message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    if (message.seqnum !== 0) {
      obj.seqnum = Math.round(message.seqnum);
    }
    if (message.piece !== undefined) {
      obj.piece = PieceDataShared.toJSON(message.piece);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PieceDataForMove>, I>>(base?: I): PieceDataForMove {
    return PieceDataForMove.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PieceDataForMove>, I>>(object: I): PieceDataForMove {
    const message = createBasePieceDataForMove();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.seqnum = object.seqnum ?? 0;
    message.piece = (object.piece !== undefined && object.piece !== null)
      ? PieceDataShared.fromPartial(object.piece)
      : undefined;
    return message;
  },
};

function createBasePieceDataForSnapshot(): PieceDataForSnapshot {
  return { dx: 0, dy: 0, piece: undefined };
}

export const PieceDataForSnapshot: MessageFns<PieceDataForSnapshot> = {
  encode(message: PieceDataForSnapshot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dx !== 0) {
      writer.uint32(8).int32(message.dx);
    }
    if (message.dy !== 0) {
      writer.uint32(16).int32(message.dy);
    }
    if (message.piece !== undefined) {
      PieceDataShared.encode(message.piece, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PieceDataForSnapshot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePieceDataForSnapshot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.dx = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.dy = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.piece = PieceDataShared.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PieceDataForSnapshot {
    return {
      dx: isSet(object.dx) ? globalThis.Number(object.dx) : 0,
      dy: isSet(object.dy) ? globalThis.Number(object.dy) : 0,
      piece: isSet(object.piece) ? PieceDataShared.fromJSON(object.piece) : undefined,
    };
  },

  toJSON(message: PieceDataForSnapshot): unknown {
    const obj: any = {};
    if (message.dx !== 0) {
      obj.dx = Math.round(message.dx);
    }
    if (message.dy !== 0) {
      obj.dy = Math.round(message.dy);
    }
    if (message.piece !== undefined) {
      obj.piece = PieceDataShared.toJSON(message.piece);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PieceDataForSnapshot>, I>>(base?: I): PieceDataForSnapshot {
    return PieceDataForSnapshot.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PieceDataForSnapshot>, I>>(object: I): PieceDataForSnapshot {
    const message = createBasePieceDataForSnapshot();
    message.dx = object.dx ?? 0;
    message.dy = object.dy ?? 0;
    message.piece = (object.piece !== undefined && object.piece !== null)
      ? PieceDataShared.fromPartial(object.piece)
      : undefined;
    return message;
  },
};

function createBaseServerMovesAndCaptures(): ServerMovesAndCaptures {
  return { moves: [], captures: [] };
}

export const ServerMovesAndCaptures: MessageFns<ServerMovesAndCaptures> = {
  encode(message: ServerMovesAndCaptures, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.moves) {
      PieceDataForMove.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.captures) {
      PieceCapture.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerMovesAndCaptures {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerMovesAndCaptures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.moves.push(PieceDataForMove.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.captures.push(PieceCapture.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerMovesAndCaptures {
    return {
      moves: globalThis.Array.isArray(object?.moves) ? object.moves.map((e: any) => PieceDataForMove.fromJSON(e)) : [],
      captures: globalThis.Array.isArray(object?.captures)
        ? object.captures.map((e: any) => PieceCapture.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ServerMovesAndCaptures): unknown {
    const obj: any = {};
    if (message.moves?.length) {
      obj.moves = message.moves.map((e) => PieceDataForMove.toJSON(e));
    }
    if (message.captures?.length) {
      obj.captures = message.captures.map((e) => PieceCapture.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerMovesAndCaptures>, I>>(base?: I): ServerMovesAndCaptures {
    return ServerMovesAndCaptures.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerMovesAndCaptures>, I>>(object: I): ServerMovesAndCaptures {
    const message = createBaseServerMovesAndCaptures();
    message.moves = object.moves?.map((e) => PieceDataForMove.fromPartial(e)) || [];
    message.captures = object.captures?.map((e) => PieceCapture.fromPartial(e)) || [];
    return message;
  },
};

function createBaseServerStateSnapshot(): ServerStateSnapshot {
  return { xCoord: 0, yCoord: 0, seqnum: 0, pieces: [] };
}

export const ServerStateSnapshot: MessageFns<ServerStateSnapshot> = {
  encode(message: ServerStateSnapshot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.xCoord !== 0) {
      writer.uint32(8).uint32(message.xCoord);
    }
    if (message.yCoord !== 0) {
      writer.uint32(16).uint32(message.yCoord);
    }
    if (message.seqnum !== 0) {
      writer.uint32(24).uint64(message.seqnum);
    }
    for (const v of message.pieces) {
      PieceDataForSnapshot.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerStateSnapshot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerStateSnapshot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.xCoord = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.yCoord = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.seqnum = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pieces.push(PieceDataForSnapshot.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerStateSnapshot {
    return {
      xCoord: isSet(object.xCoord) ? globalThis.Number(object.xCoord) : 0,
      yCoord: isSet(object.yCoord) ? globalThis.Number(object.yCoord) : 0,
      seqnum: isSet(object.seqnum) ? globalThis.Number(object.seqnum) : 0,
      pieces: globalThis.Array.isArray(object?.pieces)
        ? object.pieces.map((e: any) => PieceDataForSnapshot.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ServerStateSnapshot): unknown {
    const obj: any = {};
    if (message.xCoord !== 0) {
      obj.xCoord = Math.round(message.xCoord);
    }
    if (message.yCoord !== 0) {
      obj.yCoord = Math.round(message.yCoord);
    }
    if (message.seqnum !== 0) {
      obj.seqnum = Math.round(message.seqnum);
    }
    if (message.pieces?.length) {
      obj.pieces = message.pieces.map((e) => PieceDataForSnapshot.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerStateSnapshot>, I>>(base?: I): ServerStateSnapshot {
    return ServerStateSnapshot.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerStateSnapshot>, I>>(object: I): ServerStateSnapshot {
    const message = createBaseServerStateSnapshot();
    message.xCoord = object.xCoord ?? 0;
    message.yCoord = object.yCoord ?? 0;
    message.seqnum = object.seqnum ?? 0;
    message.pieces = object.pieces?.map((e) => PieceDataForSnapshot.fromPartial(e)) || [];
    return message;
  },
};

function createBasePosition(): Position {
  return { x: 0, y: 0 };
}

export const Position: MessageFns<Position> = {
  encode(message: Position, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(8).uint32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(16).uint32(message.y);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Position {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.x = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.y = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Position {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: Position): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = Math.round(message.x);
    }
    if (message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Position>, I>>(base?: I): Position {
    return Position.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Position>, I>>(object: I): Position {
    const message = createBasePosition();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseServerInitialState(): ServerInitialState {
  return { playingWhite: false, position: undefined, snapshot: undefined };
}

export const ServerInitialState: MessageFns<ServerInitialState> = {
  encode(message: ServerInitialState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playingWhite !== false) {
      writer.uint32(8).bool(message.playingWhite);
    }
    if (message.position !== undefined) {
      Position.encode(message.position, writer.uint32(18).fork()).join();
    }
    if (message.snapshot !== undefined) {
      ServerStateSnapshot.encode(message.snapshot, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerInitialState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerInitialState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.playingWhite = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.position = Position.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.snapshot = ServerStateSnapshot.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerInitialState {
    return {
      playingWhite: isSet(object.playingWhite) ? globalThis.Boolean(object.playingWhite) : false,
      position: isSet(object.position) ? Position.fromJSON(object.position) : undefined,
      snapshot: isSet(object.snapshot) ? ServerStateSnapshot.fromJSON(object.snapshot) : undefined,
    };
  },

  toJSON(message: ServerInitialState): unknown {
    const obj: any = {};
    if (message.playingWhite !== false) {
      obj.playingWhite = message.playingWhite;
    }
    if (message.position !== undefined) {
      obj.position = Position.toJSON(message.position);
    }
    if (message.snapshot !== undefined) {
      obj.snapshot = ServerStateSnapshot.toJSON(message.snapshot);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerInitialState>, I>>(base?: I): ServerInitialState {
    return ServerInitialState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerInitialState>, I>>(object: I): ServerInitialState {
    const message = createBaseServerInitialState();
    message.playingWhite = object.playingWhite ?? false;
    message.position = (object.position !== undefined && object.position !== null)
      ? Position.fromPartial(object.position)
      : undefined;
    message.snapshot = (object.snapshot !== undefined && object.snapshot !== null)
      ? ServerStateSnapshot.fromPartial(object.snapshot)
      : undefined;
    return message;
  },
};

function createBaseServerAdoption(): ServerAdoption {
  return { adoptedIds: [] };
}

export const ServerAdoption: MessageFns<ServerAdoption> = {
  encode(message: ServerAdoption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.adoptedIds) {
      writer.uint32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerAdoption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerAdoption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.adoptedIds.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.adoptedIds.push(reader.uint32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerAdoption {
    return {
      adoptedIds: globalThis.Array.isArray(object?.adoptedIds)
        ? object.adoptedIds.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: ServerAdoption): unknown {
    const obj: any = {};
    if (message.adoptedIds?.length) {
      obj.adoptedIds = message.adoptedIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerAdoption>, I>>(base?: I): ServerAdoption {
    return ServerAdoption.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerAdoption>, I>>(object: I): ServerAdoption {
    const message = createBaseServerAdoption();
    message.adoptedIds = object.adoptedIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseServerBulkCapture(): ServerBulkCapture {
  return { seqnum: 0, capturedIds: [] };
}

export const ServerBulkCapture: MessageFns<ServerBulkCapture> = {
  encode(message: ServerBulkCapture, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.seqnum !== 0) {
      writer.uint32(8).uint64(message.seqnum);
    }
    writer.uint32(18).fork();
    for (const v of message.capturedIds) {
      writer.uint32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerBulkCapture {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerBulkCapture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.seqnum = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.capturedIds.push(reader.uint32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.capturedIds.push(reader.uint32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerBulkCapture {
    return {
      seqnum: isSet(object.seqnum) ? globalThis.Number(object.seqnum) : 0,
      capturedIds: globalThis.Array.isArray(object?.capturedIds)
        ? object.capturedIds.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: ServerBulkCapture): unknown {
    const obj: any = {};
    if (message.seqnum !== 0) {
      obj.seqnum = Math.round(message.seqnum);
    }
    if (message.capturedIds?.length) {
      obj.capturedIds = message.capturedIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerBulkCapture>, I>>(base?: I): ServerBulkCapture {
    return ServerBulkCapture.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerBulkCapture>, I>>(object: I): ServerBulkCapture {
    const message = createBaseServerBulkCapture();
    message.seqnum = object.seqnum ?? 0;
    message.capturedIds = object.capturedIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseServerMessage(): ServerMessage {
  return { payload: undefined };
}

export const ServerMessage: MessageFns<ServerMessage> = {
  encode(message: ServerMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.payload?.$case) {
      case "initialState":
        ServerInitialState.encode(message.payload.value, writer.uint32(10).fork()).join();
        break;
      case "snapshot":
        ServerStateSnapshot.encode(message.payload.value, writer.uint32(18).fork()).join();
        break;
      case "movesAndCaptures":
        ServerMovesAndCaptures.encode(message.payload.value, writer.uint32(26).fork()).join();
        break;
      case "validMove":
        ServerValidMove.encode(message.payload.value, writer.uint32(34).fork()).join();
        break;
      case "invalidMove":
        ServerInvalidMove.encode(message.payload.value, writer.uint32(42).fork()).join();
        break;
      case "pong":
        ServerPong.encode(message.payload.value, writer.uint32(50).fork()).join();
        break;
      case "adoption":
        ServerAdoption.encode(message.payload.value, writer.uint32(58).fork()).join();
        break;
      case "bulkCapture":
        ServerBulkCapture.encode(message.payload.value, writer.uint32(66).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = { $case: "initialState", value: ServerInitialState.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = { $case: "snapshot", value: ServerStateSnapshot.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.payload = {
            $case: "movesAndCaptures",
            value: ServerMovesAndCaptures.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.payload = { $case: "validMove", value: ServerValidMove.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.payload = { $case: "invalidMove", value: ServerInvalidMove.decode(reader, reader.uint32()) };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.payload = { $case: "pong", value: ServerPong.decode(reader, reader.uint32()) };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.payload = { $case: "adoption", value: ServerAdoption.decode(reader, reader.uint32()) };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.payload = { $case: "bulkCapture", value: ServerBulkCapture.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerMessage {
    return {
      payload: isSet(object.initialState)
        ? { $case: "initialState", value: ServerInitialState.fromJSON(object.initialState) }
        : isSet(object.snapshot)
        ? { $case: "snapshot", value: ServerStateSnapshot.fromJSON(object.snapshot) }
        : isSet(object.movesAndCaptures)
        ? { $case: "movesAndCaptures", value: ServerMovesAndCaptures.fromJSON(object.movesAndCaptures) }
        : isSet(object.validMove)
        ? { $case: "validMove", value: ServerValidMove.fromJSON(object.validMove) }
        : isSet(object.invalidMove)
        ? { $case: "invalidMove", value: ServerInvalidMove.fromJSON(object.invalidMove) }
        : isSet(object.pong)
        ? { $case: "pong", value: ServerPong.fromJSON(object.pong) }
        : isSet(object.adoption)
        ? { $case: "adoption", value: ServerAdoption.fromJSON(object.adoption) }
        : isSet(object.bulkCapture)
        ? { $case: "bulkCapture", value: ServerBulkCapture.fromJSON(object.bulkCapture) }
        : undefined,
    };
  },

  toJSON(message: ServerMessage): unknown {
    const obj: any = {};
    if (message.payload?.$case === "initialState") {
      obj.initialState = ServerInitialState.toJSON(message.payload.value);
    } else if (message.payload?.$case === "snapshot") {
      obj.snapshot = ServerStateSnapshot.toJSON(message.payload.value);
    } else if (message.payload?.$case === "movesAndCaptures") {
      obj.movesAndCaptures = ServerMovesAndCaptures.toJSON(message.payload.value);
    } else if (message.payload?.$case === "validMove") {
      obj.validMove = ServerValidMove.toJSON(message.payload.value);
    } else if (message.payload?.$case === "invalidMove") {
      obj.invalidMove = ServerInvalidMove.toJSON(message.payload.value);
    } else if (message.payload?.$case === "pong") {
      obj.pong = ServerPong.toJSON(message.payload.value);
    } else if (message.payload?.$case === "adoption") {
      obj.adoption = ServerAdoption.toJSON(message.payload.value);
    } else if (message.payload?.$case === "bulkCapture") {
      obj.bulkCapture = ServerBulkCapture.toJSON(message.payload.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerMessage>, I>>(base?: I): ServerMessage {
    return ServerMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerMessage>, I>>(object: I): ServerMessage {
    const message = createBaseServerMessage();
    switch (object.payload?.$case) {
      case "initialState": {
        if (object.payload?.value !== undefined && object.payload?.value !== null) {
          message.payload = { $case: "initialState", value: ServerInitialState.fromPartial(object.payload.value) };
        }
        break;
      }
      case "snapshot": {
        if (object.payload?.value !== undefined && object.payload?.value !== null) {
          message.payload = { $case: "snapshot", value: ServerStateSnapshot.fromPartial(object.payload.value) };
        }
        break;
      }
      case "movesAndCaptures": {
        if (object.payload?.value !== undefined && object.payload?.value !== null) {
          message.payload = {
            $case: "movesAndCaptures",
            value: ServerMovesAndCaptures.fromPartial(object.payload.value),
          };
        }
        break;
      }
      case "validMove": {
        if (object.payload?.value !== undefined && object.payload?.value !== null) {
          message.payload = { $case: "validMove", value: ServerValidMove.fromPartial(object.payload.value) };
        }
        break;
      }
      case "invalidMove": {
        if (object.payload?.value !== undefined && object.payload?.value !== null) {
          message.payload = { $case: "invalidMove", value: ServerInvalidMove.fromPartial(object.payload.value) };
        }
        break;
      }
      case "pong": {
        if (object.payload?.value !== undefined && object.payload?.value !== null) {
          message.payload = { $case: "pong", value: ServerPong.fromPartial(object.payload.value) };
        }
        break;
      }
      case "adoption": {
        if (object.payload?.value !== undefined && object.payload?.value !== null) {
          message.payload = { $case: "adoption", value: ServerAdoption.fromPartial(object.payload.value) };
        }
        break;
      }
      case "bulkCapture": {
        if (object.payload?.value !== undefined && object.payload?.value !== null) {
          message.payload = { $case: "bulkCapture", value: ServerBulkCapture.fromPartial(object.payload.value) };
        }
        break;
      }
    }
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string; value: unknown } ? { $case: T["$case"]; value?: DeepPartial<T["value"]> }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
